
## Transaction
질의(Query)를 하나의 묶음으로 처리해서 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 `Rollback(Noting)`을 수행하고, 오류없이 실행을 마치면 `Commit(All)`을 하는 실행 단위를 의미한다.

- 다수의 사용자가 DB를 동시에 접근하도록 허용하면서 일관성을 유지하도록 보장
- 일관성을 보장하기 위해 전부 수행되던가, 하나도 수행되면 안됨(All or Nothing)
- DBMS의 트랜잭션 관리 모듈(동시성 제어 모듈, 회복 모듈로 구성) 담당 
	- 동시성 제어 모듈: 동시에 수행되는 여러 트랜잭션들 간의 상호 작용 제어
	- 회복 모듈: DB 갱신 도중 시스템이 고장나도 DB의 일관성을 유지되도록 보장

---
## ACID 원칙

- Transaction은 아래 네 가지 특성을 모두 만족해야 한다

#### 원자성(Atomicity)
한 트랜잭션 내 모든 연산들이 완전히 수행되거나 전혀 수행되지 않아야 한다.
즉, 한 트랜잭션 내 모든 연산이 데이터베이스에 모두 반영되거나 전혀 반영되지 않아야 한다. 시스템이 트랜잭션 중간에 다운되면 DBMS의 `회복 모듈`이 데이터베이스를 갱신한 트랜잭션의 영향을 취소시켜 트랜잭션의 원자성을 보장한다.

#### 일관성(Consistency)
한 트랜잭션이 정확하게 수행되고 나면 데이터베이스가 하나의 일관된 상태에서 다른 일관된 상태로 바뀐다. DBMS는 `CREATE TABLE`문에서 정의된 무결성 제약조건들을 유지한다. 하지만 동시에 다수 사용자가 데이터베이스에 접근하여 갱신 및 검색 연산을 수행하는 경우 무결성 제약조건만 가지고 일관성을 보장할 수 없기 때문에 `동시성 제어 모듈`이 다수 사용자의 서로 상충되는 데이터베이스 접근을 조정한다.

#### 고립성(Isolation)
한 트랜잭션이 데이터를 갱신하는 동안 다른 트랜잭션들이 접근하지 못하도록 해야한다.
트랜잭션들의 직렬 수행은 일관성을 보장하지만 성능상 적절하지 않다. 따라서 DBMS의 `동시성 제어 모듈`이 트랜잭션의 고립성을 보장하기 위해 다양한 `고립 수준(Isolation Level)`을 제공한다.

#### 지속성(Durability)
한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후 시스템에 고장이 발생하더라도 손실되지 않는다. DBMS의 `회복 모듈`은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장한다.


---

## 동시성 제어

각 트랜잭션은 데이터베이스의 일관성을 유지하므로 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 수행하는 `직렬 스케줄(Serial Schedule)`에서는 데이터베이스의 일관성이 보장된다. 여러 트랜잭션을 동시에 수행하는 `비직렬 스케줄(Non-Serial Schedule)`의 결과가 어떤 직렬 스케줄의 결과와 동일하다면 `직렬가능(Serializable)`하다고 말한다.

#### 다수 트랜잭션 병렬수행 시 발생가능한 문제

##### 갱신 손실(Lost Update)
두개 이상의 트랜잭션이 한개의 데이터를 동시에 갱신(Update)할 때 발생,
수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 이전 갱신이 무효가 되는 것

##### 오손 데이터 읽기(Dirty Read)
완료되지 않은 트랜잭션(Rollback 된)이 갱신한 데이터를 읽는 것
즉, `읽기 작업을 하는 트랜잭션1`이 `쓰기 작업을 하는 트랜잭션2`가 작업한 중간 데이터를 읽는 경우, 어떠한 이유로 `트랜잭션2`가 작업을 롤백할 경우 `트랜잭션1`은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출하게 됨


##### 반복할 수 없는 읽기(Unrepeatable Read)
한 트랜잭션이 동일한 데이터를 여러 번 읽을 때, 서로 다른 값을 읽는 것
즉, `트랜잭션1`이 데이터를 읽고, `트랜잭션2`가 데이터를 갱신하고, 다시 `트랜잭션1`이 데이터를 읽을 때 이전의 결과와 일치하지 않는 현상 발생


---

## 회복

##### 고장 유형
- 재해적 고장: 디스크가 손상을 입어 데이터베이스를 읽을 수 없는 고장
- 비재해적 고장: 재해적 고장 외의 고장

##### 비재해적 고장 회복 알고리즘
- 로그를 기반으로 한 **즉시 갱신**
- 로그를 기반으로 한 지연 갱선
- 그림자 페이징

##### 즉시 갱신
즉시 갱신에서는 트랜잭션이 데이터베이스를 갱신한 사항이 주기억 장치의 버퍼에 유지되다가 트랜잭션이 완료되기 전이라도 디스크의 데이터베이스에 기록될 수 있다.
데이터베이스의 항목에 영향을 미치는 모든 트랜잭션의 연산(갱신 연산)들에 대해 로그 레코드를 기록, 각 로그 레코드는 `로그 순서 번호(LSN, Log Sequance Number)`로 식별된다.

##### 로그 레코드 유형
- `[TID, start]`: 한 트랜잭션이 생성될 때 기록되는 로그 레코드
- `[TID, X, old_value, new_value]`: 데이터 항목 X가 old_value에서 new_value로 갱신
- `[TID, commit]`: 주어진 TID를 갖는 트랜잭션에 대한 갱신 연산이 모두 성공
- `[TID, abort]`: 주어진 TID를 갖는 트랜잭션이 철회되었음을 나타내는 로그 레코드 

##### 회복 과정
- \[TID, start\],  \[TID, commit\] 레코드가 모두 존재하는 트랜잭션들은 재수행
- \[TID, start\]만 존재하는 레코드는 취소

트랜잭션의 재수행(REDO)은 로그가 기록된 방향으로 진행되고, 취소(UNDO)는 로그를 역방향으로 따라가면서 진행된다.

##### 체크포인트

![](images/database/checkpoint.png)

DBMS는 회복시 재수행할 트랜잭션의 수를 줄이기 위해 주기적으로 체크포인트를 수행.
체크포인트를 수행하면 디스크 상에서의 로그와 데이터베이스의 내용이 일치하게 되고, 체크포인트 작업이 끝나면 로그에 `[checkpoint]` 로그 레코드가 기록된다.

일반적으로 체크포인트는 10~20분마다 한번씩 수행되고, 진행 과정은 다음과 같다.
1. 현재 수행 중인 트랜잭션을 일시 중단
2. 주기억 장치의 로그 버퍼를 디스크에 강제로 출력
3. 주기억 장치의 데이터베이스 버퍼를 디스크에 강제로 출력
4. `[checkpoint]` 로그 레코드를 로그 버퍼에 기록 후 디스크에 강제 출력
5. 일시 중단된 트랜잭션 수행 재개

---
## References
- https://victorydntmd.tistory.com/129