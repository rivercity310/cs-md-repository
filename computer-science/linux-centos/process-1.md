
## 프로세스
현재 시스템에서 `실행 중인 프로그램`을 의미한다. 리눅스의 프로세스는 운영에 필요한 다양한 기능을 수행하는 `시스템 프로세스`와 사용자가 실행한 프로그램인 `사용자 프로세스`로 나뉜다.

리눅스에서 모든 프로세스는 `부모-자식 관계`를 가지고, 필요에 따라 부모 프로세스는 자식 프로세스를 생성한다. 리눅스 시스템을 부팅할 때 스케줄러가 실행한 프로세스인 `systemd`와 `kthreadd` 프로세스를 제외한 모든 프로세스는 부모 프로세스를 가진다.

- **systemd: PID 1번 프로세스, 모든 시스템 프로세스의 부모 프로세스**
- **kthreadd: PID 2번 프로세스, 모든 스레드의 부모 프로세스**

## 프로세스 종류

#### 데몬 프로세스
특정 서비스를 제공하기 위한 프로세스로 리눅스 커널에 의해 실행된다.  `데몬`은 평소 대기 상태로 있다가 서비스 요청이 들어오면 서비스를 제공한다. 대표적으로 `SSH 서버 데몬`인 sshd 프로세스가 있다.

#### 고아 프로세스
자식 프로세스가 아직 실행 중인 상태에서 부모 프로세스가 종료된 경우 자식 프로세스는 `고아 프로세스(Orphan Process)`가 된다. 이 경우 1번 프로세스 `systemd`가 고아 프로세스의 새로운 부모 프로세스가 되어 고아 프로세스가 작업을 종료하고 마칠 수 있게 한다.

#### 좀비 프로세스
자식 프로세스는 종료될 때 부모 프로세스에 `종료 정보(exit status)`를 보내고, 부모 프로세스가 이 정보를 받으면 자식 프로세스는 프로세스 테이블 목록에서 삭제된다. 하지만 자식 프로세스가 실행을 종료했는데도 프로세스 테이블 목록에 남아있는 경우 이 프로세스를 `좀비 프로세스`라 한다. 

`좀비 프로세스`는 부모 프로세스가 자식 프로세스의 종료 정보를 제대로 처리하지 않았기 때문에 발생하며, 자식 프로세스는 자신의 종료 정보를 부모 프로세스가 읽어 가기를 기다리고 있는 것이다. 

`좀비 프로세스`는 프로세스 목록에 `defunct` 프로세스라고 나오기도 한다. 좀비 프로세스는 `kill` 명령으로 제거할 수 없고, `SIGCHLD` 시그널을 부모 프로세스에 보내어 부모 프로세스가 자식 프로세스를 정리하도록 하거나 부모 프로세스 자체를 종료해야 한다.

부모 프로세스가 종료되면 `좀비 프로세스`는 `고아 프로세스`가 되고, 새로운 부모인 `systemd` 프로세스가 주기적으로 자식 프로세스의 종료 정보를 확인하여 정리한다.

---

## 프로세스 관리 명령

### ps
- 프로세스 목록 확인
- 유닉스 옵션
	- `-e`: 시스템에서 실행 중인 모든 프로세스 정보 출력
	- `-f`: 프로세스에 대한 자세한 정보 출력
	- `-u uid`: 특정 사용자에 대한 모든 프로세스 정보 출력
	- `-p pid`: pid로 지정한 특정 프로세스 정보 출력
- 이외에도 `BSD 옵션`과 `GNU 옵션`이 있다

#### `ps -f`의 출력 정보
- UID: 프로세스를 실행한 사용자 ID
- PID: 프로세스 번호
- PPID: 부모 프로세스 번호
- C: CPU 사용량 퍼센트
- STIME: 프로세스의 시작 날짜나 시간
- TTY: 프로세스가 실행한 터미널의 종류와 번호
- TIME: 프로세스 실행 시간
- CMD: 실행되고 있는 프로그램 이름(명령)

**TTY의 값이 `?`인 것은 대부분 시스템이 실행한 데몬 프로세스이다.**
**또한 스레드는 CMD에 `[ ]`로 감싸 구분한다.**


### pgrep
전체 프로세스 목록에서 특정 프로세스만 골라서 확인하는 방법으로 ps 명령을 grep과 파이프로 연결한 기능을 pgrep 명령으로 한번에 제공한다.

- 형식: pgrep \[옵션\] \[패턴\]
- 옵션
	- `-x`: 패턴과 정확히 일치하는 프로세스의 PID 출력
	- `-n`: 패턴을 포함하고 있는 가장 최근 프로세스 정보 출력
	- `-u 사용자 이름`: 특정 사용자에 대한 모든 프로세스 정보 출력
	- `-l`: PID와 프로세스 이름 출력
	- `-t term`: 특정 단말기와 관련된 프로세스 정보 출력

더 자세한 정보를 검색하려면 pgrep 명령을 ps 명령과 연결해서 사용해야 한다.
pgrep 명령으로 검색하려는 프로세스의 `PID`를 찾아 ps 명령으로 자세한 정보를 확인하는 방식으로 사용법은 다음과 같다.
```bash
ps -fp $(pgrep -x bash)
```


### 프로세스 종료
프로세스를 강제로 종료하려면 해당 프로세스의 `PID`를 알아야 한다. 프로세스를 종료하기 위해서는 `kill` 명령이나 `pkill` 명령을 사용하고, 이 명령들은 프로세스에 시그널을 보내 프로세스를 종료한다.

시그널은 프로세스에 무언가 발생했음을 알리는 간단한 메세지로 미리 정의된 상수를 사용한다. 시그널은 번호로 구분되며 이름을 가지고 있다. 시그널의 종류는 `kill -l` 명령으로 알 수 있고, 시그널을 받은 프로세스는 기본적으로 종료된다.

#### 시그널
주요 시그널 목록은 다음과 같다. `(시그널, 번호, 기본 처리): 설명` 순서
- `(SIGHUP 1 종료)`: 터미널과의 연결이 끊어졌을 때 발생
- `(SIGINT 2 종료)`: 인터럽트로 사용자가 `Ctrl + c` 입력시 발생
- `(SIGQUIT 3 종료, 코어덤프)`: 종료 신호로 사용자가 `Ctrl + \` 입력시 발생
- `(SIGKILL 9 종료)`: 이 시그널을 받은 프로세스는 무시할 수 없고 강제로 종료된다.
- `(SIGALRM 14 종료)`: 알람에 의해 발생
- `(SIGTERM 15 종료)`: kill 명령이 보내는 기본 시그널, 무시될 수 있다.

#### kill
- 인자로 지정한 프로세스에 시그널을 전달
- 형식: kill \[- 시그널\] PID
- 시그널
	- 9: 강제 종료
	- 15: 프로세스와 관련된 파일들을 정리하고 종료 (기본 kill 명령어의 시그널)
	- 2: 인터럽트 시그널 (사용자 `Ctrl + C` 입력시 발생)

```bash
kill -9 $(pgrep -x man)   // man 프로세스 강제 종료
```

#### pkill(= killall)
- kill과 동일하게 프로세스에 시그널을 보내지만, 명령 이름으로 찾아 종료한다.
- 같은 명령이 여러 개인 경우 전부 종료되고, 자신의 프로세스만 종료할 수 있다.
```bash
pkill man
또는
killall man
```


### 프로세스 관리 도구
현재 프로세스 목록 정보를 가공하여 사용자가 보기 편하고 다양한 기능을 제공하는 도구가 있다. 대표적으로 CentOS의 GUI인 `그놈`이 제공하는 `시스템 정보`와 `top 명령`이 있다.
`top` 명령은 현재 실행 중인 프로세스의 정보를 주기적으로 출력하고, `시스템 정보`는 `유틸리티` 내에서 찾을 수 있다.

#### top 내부 명령 목록
- `Space Bar`, `Enter`: 화면을 즉시 다시 출력
- `h`, `?`: 도움말 화면 출력
- `k`: 프로세스 종료, 종료할 프로세스의 pid를 물어본다.
- `n`: 출력하는 프로세스의 개수 변경
- `u`: 사용자에 따라 정렬하여 출력
- `M`: 사용하는 메모리 크기에 따라 정렬하여 출력
- `p`: CPU 사용량에 따라 정렬하여 출력
- `q`: top 명령 종료

#### top 명령의 출력 정보
- PID, USER, %CPU, %MEM
- PR: 우선순위
- NI: Nice 값
- VIRT: 프로세스가 사용하는 가상 메모리의 크기
- RES: 프로세스가 사용하는 메모리의 크기
- SHR: 프로세스가 사용하는 공유 메모리의 크기
- TIME+: CPU 누적 이용 시간
- COMMAND: 명령 이름

---


