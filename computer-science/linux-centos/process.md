## 프로세스
현재 시스템에서 `실행 중인 프로그램`을 의미한다. 리눅스의 프로세스는 운영에 필요한 다양한 기능을 수행하는 `시스템 프로세스`와 사용자가 실행한 프로그램인 `사용자 프로세스`로 나뉜다.

리눅스에서 모든 프로세스는 `부모-자식 관계`를 가지고, 필요에 따라 부모 프로세스는 자식 프로세스를 생성한다. 리눅스 시스템을 부팅할 때 스케줄러가 실행한 프로세스인 `systemd`와 `kthreadd` 프로세스를 제외한 모든 프로세스는 부모 프로세스를 가진다.

- **systemd: PID 1번 프로세스, 모든 시스템 프로세스의 부모 프로세스**
- **kthreadd: PID 2번 프로세스, 모든 스레드의 부모 프로세스**

## 프로세스 종류

#### 데몬 프로세스
특정 서비스를 제공하기 위한 프로세스로 리눅스 커널에 의해 실행된다.  `데몬`은 평소 대기 상태로 있다가 서비스 요청이 들어오면 서비스를 제공한다. 대표적으로 `SSH 서버 데몬`인 sshd 프로세스가 있다.

#### 고아 프로세스
자식 프로세스가 아직 실행 중인 상태에서 부모 프로세스가 종료된 경우 자식 프로세스는 `고아 프로세스(Orphan Process)`가 된다. 이 경우 1번 프로세스 `systemd`가 고아 프로세스의 새로운 부모 프로세스가 되어 고아 프로세스가 작업을 종료하고 마칠 수 있게 한다.

#### 좀비 프로세스
자식 프로세스는 종료될 때 부모 프로세스에 `종료 정보(exit status)`를 보내고, 부모 프로세스가 이 정보를 받으면 자식 프로세스는 프로세스 테이블 목록에서 삭제된다. 하지만 자식 프로세스가 실행을 종료했는데도 프로세스 테이블 목록에 남아있는 경우 이 프로세스를 `좀비 프로세스`라 한다. 

`좀비 프로세스`는 부모 프로세스가 자식 프로세스의 종료 정보를 제대로 처리하지 않았기 때문에 발생하며, 자식 프로세스는 자신의 종료 정보를 부모 프로세스가 읽어 가기를 기다리고 있는 것이다. 

`좀비 프로세스`는 프로세스 목록에 `defunct` 프로세스라고 나오기도 한다. 좀비 프로세스는 `kill` 명령으로 제거할 수 없고, `SIGCHLD` 시그널을 부모 프로세스에 보내어 부모 프로세스가 자식 프로세스를 정리하도록 하거나 부모 프로세스 자체를 종료해야 한다.

부모 프로세스가 종료되면 `좀비 프로세스`는 `고아 프로세스`가 되고, 새로운 부모인 `systemd` 프로세스가 주기적으로 자식 프로세스의 종료 정보를 확인하여 정리한다.

---

## 프로세스 관리 명령

### ps
- 프로세스 목록 확인
- 유닉스 옵션
	- `-e`: 시스템에서 실행 중인 모든 프로세스 정보 출력
	- `-f`: 프로세스에 대한 자세한 정보 출력
	- `-u uid`: 특정 사용자에 대한 모든 프로세스 정보 출력
	- `-p pid`: pid로 지정한 특정 프로세스 정보 출력
- 이외에도 `BSD 옵션`과 `GNU 옵션`이 있다

#### `ps -f`의 출력 정보
- UID: 프로세스를 실행한 사용자 ID
- PID: 프로세스 번호
- PPID: 부모 프로세스 번호
- C: CPU 사용량 퍼센트
- STIME: 프로세스의 시작 날짜나 시간
- TTY: 프로세스가 실행된 터미널의 종류와 번호
- TIME: 프로세스 실행 시간
- CMD: 실행되고 있는 프로그램 이름(명령)

**TTY의 값이 `?`인 것은 대부분 시스템이 실행한 데몬 프로세스이다.**
**또한 스레드는 CMD에 `[ ]`로 감싸 구분한다.**

### pgrep
전체 프로세스 목록에서 특정 프로세스만 골라서 확인하는 방법으로 ps 명령을 grep과 파이프로 연결한 기능을 pgrep 명령으로 한번에 제공한다.

- 형식: pgrep \[옵션\] \[패턴\]
- 옵션
	- `-x`: 패턴과 정확히 일치하는 프로세스의 PID 출력
	- `-n`: 패턴을 포함하고 있는 가장 최근 프로세스 정보 출력
	- `-u 사용자 이름`: 특정 사용자에 대한 모든 프로세스 정보 출력
	- `-l`: PID와 프로세스 이름 출력
	- `-t term`: 특정 단말기와 관련된 프로세스 정보 출력

더 자세한 정보를 검색하려면 pgrep 명령을 ps 명령과 연결해서 사용해야 한다.
pgrep 명령으로 검색하려는 프로세스의 `PID`를 찾아 ps 명령으로 자세한 정보를 확인하는 방식으로 사용법은 다음과 같다.
```bash
ps -fp $(pgrep -x bash)
```


### 프로세스 종료
프로세스를 강제로 종료하려면 해당 프로세스의 `PID`를 알아야 한다. 프로세스를 종료하기 위해서는 `kill` 명령이나 `pkill` 명령을 사용하고, 이 명령들은 프로세스에 시그널을 보내 프로세스를 종료한다.

시그널은 프로세스에 무언가 발생했음을 알리는 간단한 메세지로 미리 정의된 상수를 사용한다. 시그널은 번호로 구분되며 이름을 가지고 있다. 시그널의 종류는 `kill -l` 명령으로 알 수 있고, 시그널을 받은 프로세스는 기본적으로 종료된다.

#### 시그널
주요 시그널 목록은 다음과 같다. `(시그널, 번호, 기본 처리): 설명` 순서
- `(SIGHUP 1 종료)`: 터미널과의 연결이 끊어졌을 때 발생
- `(SIGINT 2 종료)`: 인터럽트로 사용자가 `Ctrl + c` 입력시 발생
- `(SIGQUIT 3 종료, 코어덤프)`: 종료 신호로 사용자가 `Ctrl + \` 입력시 발생
- `(SIGKILL 9 종료)`: 이 시그널을 받은 프로세스는 무시할 수 없고 강제로 종료된다.
- `(SIGALRM 14 종료)`: 알람에 의해 발생
- `(SIGTERM 15 종료)`: kill 명령이 보내는 기본 시그널, 무시될 수 있다.

#### kill
- 인자로 지정한 프로세스에 시그널을 전달
- 형식: kill \[- 시그널\] PID
- 시그널
	- 9: 강제 종료
	- 15: 프로세스와 관련된 파일들을 정리하고 종료 (기본 kill 명령어의 시그널)
	- 2: 인터럽트 시그널 (사용자 `Ctrl + C` 입력시 발생)

```bash
kill -9 $(pgrep -x man)   // man 프로세스 강제 종료
```

#### pkill(= killall)
- kill과 동일하게 프로세스에 시그널을 보내지만, 명령 이름으로 찾아 종료한다.
- 같은 명령이 여러 개인 경우 전부 종료되고, 자신의 프로세스만 종료할 수 있다.
```bash
pkill man
또는
killall man
```


### 프로세스 관리 도구
현재 프로세스 목록 정보를 가공하여 사용자가 보기 편하고 다양한 기능을 제공하는 도구가 있다. 대표적으로 CentOS의 GUI인 `그놈`이 제공하는 `시스템 정보`와 `top 명령`이 있다.
`top` 명령은 현재 실행 중인 프로세스의 정보를 주기적으로 출력하고, `시스템 정보`는 `유틸리티` 내에서 찾을 수 있다.

#### top 내부 명령 목록
- `Space Bar`, `Enter`: 화면을 즉시 다시 출력
- `h`, `?`: 도움말 화면 출력
- `k`: 프로세스 종료, 종료할 프로세스의 pid를 물어본다.
- `n`: 출력하는 프로세스의 개수 변경
- `u`: 사용자에 따라 정렬하여 출력
- `M`: 사용하는 메모리 크기에 따라 정렬하여 출력
- `p`: CPU 사용량에 따라 정렬하여 출력
- `q`: top 명령 종료

#### top 명령의 출력 정보
- PID, USER, %CPU, %MEM
- PR: 우선순위
- NI: Nice 값
- VIRT: 프로세스가 사용하는 가상 메모리의 크기
- RES: 프로세스가 사용하는 메모리의 크기
- SHR: 프로세스가 사용하는 공유 메모리의 크기
- TIME+: CPU 누적 이용 시간
- COMMAND: 명령 이름

---

## 작업

### Foreground & Background
`작업 제어 도구`는 한 터미널에서 동시에 여러 프로세스를 실행하고 관리하기 위해 `C셸`에서 처음 개발되었다. `작업 제어 도구`가 관리하는 프로세스를 `작업`이라고 한다.

`Foreground 작업` 혹은 `Foreground 프로세스`는 사용자가 입력한 명령이 실행되어 결과가 출력될 때까지 기다리는 방식으로 처리된다. 반면, `Background 작업`은 앞에서 `Foreground 프로세스`가 실행되는 동안 뒤에서 실행될 수 있는 프로세스로, 한 터미널에서 여러 개의 프로세스를 동시에 실행시킬 수 있게 하고, 명령의 마지막에 `&(앰퍼샌드)` 기호를 추가하여 선언한다.

`Background 작업`의 실행이 끝나면 기존의 작업 화면과 백그라운드 작업 결과가 뒤섞인 채 터미널 화면에 출력될 수 있으므로, 일반적으로 백그라운드를 처리할 때는 다음과 같이 출력과 오류 방향을 전환하고, 실행 결과와 오류 메세지는 `파일로 저장`하는 방법을 사용한다.

```shell
find / -name passwd > pw.dat 2>&1 &
```


### 작업 제어
작업 제어에는 다음 세가지가 있다.
- `작업 전환`: 포그라운드 작업과 백그라운드 작업 간의 전환
- `작업 일시 중지`: 작업을 잠시 중단
- `작업 종료`: 작업을 종료

#### jobs
`현재 실행 중인 백그라운드 작업 목록`을 보는 명령으로, 배시셸의 내부 명령이다.
작업 순서는 `+(가장 최근에 접근한 작업)`, `-(+ 작업 바로 직전에 접근한 작업)`, `공백(그 외의 작업`으로 구분되고, 작업 상태는 `Running(현재 실행 중)`, `Done(작업 정상 종료)`, `Terminated(작업 비정상 종료)`, `Stopped(작업 일시 중단)`으로 구분된다. 

- jobs \[%작업 번호\]
	- `생략`: 전체 백그라운드 작업 정보 출력
	- `%번호`: 해당 번호의 작업 정보 출력
	- `%+ 또는 %%`: 작업 순서가 `+`인 작업 정보 출력
	- `%-`: 작업 순서가 `-`인 작업 정보 출력

#### 작업 전환하기
- `Ctrl + Z`: 포그라운드 작업을 중지한다. (종료 아님)
- `Ctrl + C`: 포그라운드 작업을 종료한다. (인터럽트 시그널을 포그라운드 프로세스에 전달)
- `bg %작업번호`: 작업번호에 해당하는 작업을 `백그라운드로 전환`한다.
- `fg %작업번호`: 작업번호에 해당하는 작업을 `포그라운드로 전환`한다.

백그라운드 작업을 종료하려면 `kill` 명령으로 강제 종료해야 한다. 이때 kill 명령의 인자로 PID 대신 `%작업번호`를 지정해도 된다.

#### nohup
백그라운드 작업을 실행한 터미널이 종료되거나, 로그아웃 후에도 백그라운드 작업 계속 실행하려면 `nohup` 명령을 사용한다. `nohup` 명령을 사용하는 경우 반드시 백그라운드로 실행해야 하고, 별도로 출력 방향을 전환하지 않으면 명령의 실행 결과와 오류 메세지가 현재 디렉터리의 `nohup.out` 파일로 자동 저장된다.
```shell
nohup find / -name passwd &               // nohub.out에 저장
nohup find / -name passwd > pw.dat 2>&1   // pw.dat에 저장
```

### 작업 예약
리눅스에서는 특정한 시간에 작업을 실행하도록 예약할 수 있는 두가지 방법을 제공한다. 
첫번째는 `at` 명령을 통해 정해진 시간에 한번만 실행하는 것이고, 두번째는 `crontab` 명령을 이용해 정해진 시간에 반복적으로 실행하는 것이다.

#### at
- 형식: at \[옵션\] \[시간\]
- 옵션:
	- `-l`: 현재 실행 대기 중인 명령의 전체 목록 추력 (= atq)
	- `-r 작업번호`: 현재 실행 대기 중인 명령 중 해당 작업 번호 삭제(= atrm)
	- `-m`: 출력 결과가 없더라도 작업이 완료되면 사용자에게 메일로 알려준다.
	- `-f 파일`: 표준 입력 대신 실행할 명령을 파일로 지정한다.
- 사용 예
	- at -m 0730 tomorrow
	- at 10:00 pm
	- at 8:15 am May 30
- `atq`: 현재 사용자의 등록된 작업 목록 출력, root의 경우 모든 사용자의 작업 목록 출력
- `atrm 작업번호`: 지정된 작업번호의 작업을 삭제

at 명령과 시간을 명시하면, 프롬프트가 `at>`로 바뀌고 작업을 예약할 수 있다. at 명령에서 시간을 지정할 때는 `HH:MM` 뿐만 아니라 `HHMM`, `today`, `tomorrow`, `hours`, `days` 등을 지정할 수도 있다. at으로 실행할 명령은 기본적으로 `표준 입력`으로 지정한다. 명령의 입력을 마치려면 `Ctrl + d`를 누르고, 작업을 마치면 `<EOT>` 출력과 함께 작업이 예약된다.

```shell
$ at 04:30 pm       // 작업 예약 시간 지정
at> /usr/bin/ls -l ~user1 > ~user1/at.out   // 실행 명령 지정
at> <EOT>                                   // Ctrl + d 입력으로 종료
job 2 at Fri Nov 8 16:30:00 2023            // 작업 예약 완료
```

at으로 설정한 작업의 결과는 지정된 파일에 저장되고, 만약 표준 출력을 파일로 전환하지 않았다면 작업 결과가 메일로 전달된다. 이 경우 시스템에 메일이 설정되어 있어야 한다. at으로 생성된 작업 파일은 `/var/spool/at` 디렉터리에 저장된다. 생성된 작업 파일은 작업이 완료되면 자동으로 삭제되고, 디렉터리 `/var/spool/at`은 `root` 사용자만 읽을 수 있다.

`시스템 관리자`는 일반 사용자들이 at 명령을 사용하거나 사용하지 못하도록 제한할 수 있다. 이와 관련된 파일은 `/etc/at.allow`와 `/etc/at.deny`다. at 명령의 사용이 허용된 사용자들은 `at.allow`에 지정하고, 금지된 사용자들은 `at.deny` 파일에 저장한다. `at.allow` 파일은 필요시에 관리자가 직접 만들어야 한다.

![](images/linux/at.png)