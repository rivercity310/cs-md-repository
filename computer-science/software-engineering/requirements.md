
## 계획
폭포수 모델의 첫번째 절차로, 다음과 같은 과정을 거친다.
- 문제 정의
- 타당성 분석
- 개발 비용 산정 & 산정 기법
- 일정 계획
- 위험 분석

#### 타당성 분석
- 경제적 타당성
- 기술적 타당성
- 법적 타당성

#### 개발 비용 산정
- 영향을 주는 요소
	- 프로그래머 자질
	- 소프트웨어 복잡도
	- 소프트웨어 크기
	- 가용 시간
	- 요구되는 신뢰도 수준
	- 기술 수준

- 비용 산정 기법
	- 하향식(top-down) 산정 기법
		- 전문가 판단 기법
		- 델파이 기법
	- 상향식(bottom-up) 산정 기법
		- LOC(원시 코드 라인 수) 기법
		- 개발 단계별 노력 기법
	- 수학적 산정 기법
		- COCOMO(COnstructive COst MOdel)
		- COCOMO2
		- 기능 점수 산정 방법(FP, Functional Point)

---

## 하향식 산정 기법
과거의 유사 경험을 바탕으로 `회의`를 통해 산정하며 과학적이지는 않지만 많이 사용되는 기법

#### 전문가 판단 기법
경험이 많은 전문가들의 의견을 듣고 결정

#### 델파이 기법
`조정자(Coordinator)`와 전문가가 모여 의견을 조율하며 비용 산정
1. 간사 역할의 조정자와 전문가들이 모여 비용 산정 회의를 한다
2. 전문가 각각은 비용 산정 자료를 검토하고, 의견을 나눈다
3. 전문가 각각이 계산한 비용을 익명으로 조정자에게 제출한다
4. 조정자는 각 전문가가 제출한 자료를 요약/정리한다
5. 조정자는 각 전문가가 제출한 산정 내용의 차이가 크면 다시 회의를 소집한다
6. 각 전문가는 다시 익명으로 비용 산정 작업을 한다

---

## 상향식 산정 기법
프로젝트의 세부 작업 단위별로 비용을 산정한 후 전체 비용을 합산하는 방법.

#### 원시 코드 라인 수 기법
소프트웨어 각 기능의 원시 코드 라인 수(LOC, Line Of Code)의 `비관치`, `낙관치`, `중간치`를 측정해서 예측치를 구하고 이를 이용해 노력, 개발 비용, 개발 기간, 생산성 등의 비용을 산정하는 기법.
- 비관치: 한 모듈의 라인 수를 `가장 적게` 생각할 때 예상 LOC (가중치 1)
- 낙관치: 한 모듈의 라인 수를 `가장 많게` 생각할 때 예상 LOC (가중치 1)
- 중간치: 한 모듈의 라인 수를 `보통`이라고 생각할 때 예상 LOC (가중치 4)

- 추정 LOC = (낙관치 + 비관치 + (중간치 * 4)) / 6 -> 가중치에 대한 평균
- 노력(인/월수, MM) = (참여 인원 / 월) * 개발 기간 = 추정 LOC / 1인당 월평균 생산 코드 라인 수
- 개발 비용 = (M/M) * 단위 비용(1인당 월평균 인건비)
- 개발 기간 = (M/M) / 참여 인원
- 생산성 = LOC / (M/M)

#### ex)
1. 소프트웨어 개발 기간이 1년이고, 5명의 개발자가 12개월 동안, 7명의 개발자가 5개월 동안 참여한다면 이 소프트웨어의 노력(M/M)은?
	- => (5명 * 12개월) + (7명 * 5개월) = 95M/M

2. LOC 기법에 의해 예측한 총 라인이 50,000 라인이고, 개발자가 10명, 개발자들이 월 평균 500라인을 코딩한다면 개발 기간은?
	- M/M = 50,000 / 500 = 100
	- 개발 기간 = 100 / 10 = 10개월
	- 생산성 = 50,000 / 100 = 500
	- 개발 비용 = (인건비가 100만원이면) 100M/M * 1,000,000 = 100,000,000원

#### 개발 단계별 노력 기법
LOC 기법이 코드 라인 수 하나로만 M/M을 산정하는데 반해, 개발 단계별 노력 기법은 소프트웨어 개발 생명주기 각 단계마다 필요한 M/M을 모두 산정한다. 따라서 코딩만 대상으로 산정하는 LOC 기법보다 더 정확하다.

---

## 수학적 산정 기법
**E(Effort) = M/M(Man/Month) = P/M(Person/Month) = Manpower**

### 1. PUTNAM
소프트웨어 생명주기의 전 과정에 사용될 노력의 분포를 가정


### 2. COCOMO
상향식 비용 산정 기법으로 LOC를 예측한 후, 소프트웨어 종류에 따라 각 `비용 산정 공식`에 대입해 비용을 산정한다. 초기에 LOC를 정확히 예측하기 어렵다는 문제가 있어서 `COCOMO2` 방법이 대안으로 등장했다.

##### COCOMO 산정 시 고려 사항
- 프로그램 유형에 따른 가중치 (개발하려는 프로그램의 난이도에 비례한 가중치)
- 4가지 특성에 따른 15가지 분류 (특성에 따라 세부 보정 값으로 조정)


#### 단계1) 가중치 반영하기
다음 세 가지의 프로그램 규모(LOC)에 따른 가중치가 반영된 초기 개발 인건비(M/M) 계산
`PM = a * (KDSI)^b` 공식에 프로젝트 유형에 따른 상수값을 대입해 M/M(= P/M)을 구한다.

- 단순형 프로젝트 (~ 50KDSI) : 일반 SW (a = 2.4, b = 1.05)
- 중간형 프로젝트 (~ 300KDSI) : OS나 DBMS와 같은 SW (a = 3.0, b = 1.12)
- 내장형 프로젝트 (300KDSI ~) : 자동화 기기, 하드웨어와 밀접한 SW (a = 3.6, b = 1.20)

**KDSI**: 소프트웨어의 최종 원시 코드 라인 수 (Kilo Delivered Source Instruction)
**PM**: 소프트웨어 개발에 필요한 인력 (Person/Month = M/M)


#### 단계2) 보정 계수 반영하기
`단계 1`에서 구한 초기 인건비에 프로젝트의 15가지 속성에 따른 보정치를 부여한다.
보정에 사용되는 값을 `노력 조정 수치(EAF, Effort Adjustment Factor)`라 하고 제시된 속성 항목 중 필요한 항목의 승수 값을 모두 곱하여 구한다.
##### ex) 
요구되는 신뢰도가 높은 소프트웨어(1.15), 매우 복잡(1.30), 개발 일정 촉박(1.10), 그 외 다른 요소들은 모두 보통(1.00)인 경우 EAF는?
- => 노력 조정 수치(EAF) = 1.15 * 1.30 * 1.10 

`단계 2`를 거친 후 얻어지는 프로젝트 유형 별 PM의 값은 다음과 같다.
- 단순형: `PM = 2.4 * (KDSI)^1.05 * EAF`
- 중간형: `PM = 3.0 * (KDSI)^1.12 * EAF`
- 내장형: `PM = 3.6 * (KDSI)^1.20 * EAF`


#### 단계3) 총 개발 기간 산정하기
총 개발 기간(TDEV, Total DEVelopment time)를 구하는 공식은 다음과 같다. 개발할 소프트웨어 유형에 상관없이 모두 동일한 상수 `2.5`를 곱하고, 유형에 따라 `PM` 값에 제곱한다.
- 단순형: `TDEV = 2.5 * (PM)^0.38`
- 중간형: `TDEV = 2.5 * (PM)^0.35`
- 내장형: `TDEV = 2.5 * (PM)^0.32`

#### COCOMO2
COCOMO2 방법은 개발 초기 단계에서 `LOC`를 정확히 예측하기 어렵다는 점을 고려, 단계별로 나름의 방법으로 값을 예측한 후 이를 바탕으로 필요한 인건비를 예측하는 방식.
소프트웨어 개발 프로젝트가 `진행된 정도`에 따라 다음 3가지 다른 모델을 제시한다.

- 애플리케이션 합성 모델
	- 객체 점수(Object Point)를 산출하고 이를 바탕으로 규모 산정
		1. 개발 범위에 속한 객체(입출력화면 등)를 찾는다.
		2. 객체가 제공하는 기능의 복잡도를 분류한다. (단순, 보통, 복잡)
		3. 객체의 개수에 복잡도 분류별 가중치를 부여해 결괏값 산출

- 초기 설계 모델
	- 초기 설계 단계에서 예측값을 구함
	- 기능 점수 산정 방법을 이용해 산정 (1단계보다 더 정확한 예측이 가능하기 때문)

- 구조 설계 이후 모델
	- 3단계에서는 이미 기능 점수가 계산되었기 때문에 기능 점수를 바탕으로 LOC 추정
	- 추정된 LOC를 통해 규모 산정



### 3. 기능 점수 방법
기능 점수를 구한 후 이를 이용해 비용을 산정, 객체지향 중심의 소프트웨어 개발에서는 라인 수만으로 소프트웨어의 규모를 정확히 측정하기 어렵다. `기능 점수 방법`은 기능(입출력, DB 테이블, 인터페이스, 조회 등)의 수를 판단 근거로 삼는다. 

라인 수와 무관하게 기능이 많으면 규모도 크고 복잡도도 높다고 판단한다. `기능 점수`는 개발하려는 소프트웨어 기능의 크기를 측정하는 단위이고 기능이 얼마나 복잡한가를 상대적인 점수로 표현한다.

#### 기능 점수 산정 방법의 특징
- 구현 관점이 아닌 `사용자 관점`의 요구 기능을 정량적으로 산정
- 개발에 사용되는 언어와 무관
- 소프트웨어 개발 생명주기(SDLC) 전체 단계에서 사용 가능
- 측정의 일관성을 위해 개발 기술, 방법, 품질 수준 등은 고려하지 않음
- 개발, 유지보수, 필요한 자원을 산정하는데 이용

#### 기능 점수의 기준
FP(기능 점수)는 다음과 같이 구분된다.
-  데이터 기능
	1. 내부 논리 파일(ILF, Internal Logical File)
	2. 외부 연계 파일(EIF, External Interface File)
	
-  트랜잭션 기능
	1. 외부 입력(EI, External Input)
	2. 외부 출력(EO, External Output)
	3. 외부 조회(EQ, External inQuiry)

**기능 점수 산정 방법**은 다음 2가지로 나뉜다.
- 정규 기능 점수법
	- `설계` 단계 이후에 사용하면 유용
	- 소프트웨어 기능을 도출한 후 각 기능의 `유형별 복잡도`를 구해 정확한 FP 산정

- 간이 기능 점수법
	- `기획 및 발주` 단계에 사용
	- 소프트웨어 기능을 도출한 후 각 기능의 `평균 복잡도`를 적용해 점수 산정


#### 기능 점수 산정 방법의 장/단점
- 장점
	1. 사용자의 요구사항만으로 기능을 추출해 측정 (실제 구현 방법과 관계없이 일관적)
	2. 모든 개발 단계에서 사용 가능
	3. 개발 방법이나 개발 팀과 무관하므로 객관적이고 일관적

- 단점
	1. 요구사항만으로부터 기능을 도출하려면 높은 분석 능력이 요구
	2. 기능 점수 전문가 필요
	3. 내부 로직 위주의 SW에는 다소 부적합
	4. 개발 공수보다는 개발 규모 측정에 적합


#### 간이 기능 점수법
분석/설계 단계에서야 기능의 속성까지 상세하게 도출할 수 있기 때문에, 계획 단계에서 예산 수립 시 각 기능의 복잡도와 가중치를 도출하기 어렵다. 따라서 편의를 위해 `sw사업 대가산정 가이드`에서 제공하는 `평균 복잡도 가중치`를 이용해 기능 점수를 구한다. 

`평균 복잡도 가중치`는 ILF, EIF, EI, EO, EQ 각각에 대한 가중치를 `과거에 수행한 기능 점수 산정 결과를 분석해 5가지 유형에 적용된 복잡도를 계산한 가중치의 평균값`이다.  즉, 일종의 통계값에 해당한다.
- 내부 논리 파일(ILF): 7.5
- 외부 연계 파일(EIF): 5.4
- 외부 입력(EI): 4.0
- 외부 출력(EO): 5.2
- 외부 조회(EQ): 3.9

![](images/software-engineering/fp.png)

#### 1) 측정(계산) 유형 결정
- 개발 프로젝트 기능 점수: 프로젝트에서 제공하는 전체 기능 측정 (개발 규모 측정)
- 개선 프로젝트 기능 점수: 변경된 부분의 크기만 측정 (변경 규모 측정)
- 애플리케이션 기능 점수: 현재 운용 중인 애플리케이션 기능 측정 (개발 + 개선, 응용 규모 측정)

##### 2) 측정 범위와 애플리케이션 경계 식별
- 측정 범위: 기능 점수를 측정하고자 하는 대상
- 애플리케이션 경계: 기능 점수를 계산하는 대상을 제외한 다른 애플리케이션이나 외부 사용자를 구분한 경계, 사용자 관점에서 경계를 구분해야 함.
	- 경계가 너무 클 때: 기능 점수 `과소` 산출
	- 경계가 너무 작을 때: 기능 점수 `과대` 산출

##### 3. 데이터 기능 점수 계산
`ILF`와 `EIF`의 개수를 계산해 각각의 평균 복잡도(가중치)에 따라 결정.
**데이터 기능 점수 = (ILF 개수 * 7.5) + (EIF 개수 * 5.4)**

- ILF(내부 논리 파일)
	- DB에 존재하는 데이터 모임, 시스템 내 파일이나 클래스 등
	- 애플리케이션에 존재하는 데이터를 논리적으로 모아 놓은 파일

- EIF(외부 연계 파일)
	- 측정 대상 애플리케이션에서 참조하고 있는 다른 애플리케이션의 파일


##### 4. 트랜잭션 기능 점수 계산
`EI`, `EO`, `EQ`의 횟수

- EI(외부 입력): DB 등록, 수정, 삭제 연산
- EO(외부 출력): `계산하는 로직`을 거쳐 데이터나 정보를 사용자에게 보여주는 기능
- EQ(외부 조회): DB에 존재하는 데이터를 찾아 그대로 표시만 해주는 기능

**트랜잭션 기능 점수 = (EI 개수 * 4.0) + (EO 개수 * 5.2) + (EQ 개수 * 3.9)**


##### 5. 미조정 기능점수 결정
**미조정 기능 점수(UFP, Unadjusted FP) = 데이터 기능 점수 + 트랜잭션 기능 점수**
`UFP`는 SW의 여러가지 특성을 배제한 채, 단순히 기능적인 요구사항에 대해서만 계산된 결과이므로 특성의 값을 반영시켜야 한다.

**보정 전 개발 원가 = 미조정 기능 점수 * 기능 점수당 단가**
-> 기능 점수당 단가, 약 553.114원


##### 6. 값 조정 인자 결정
앞에 제시된 기능 점수당 단가는 개발하려는 소프트웨어의 복잡도가 `보통`임을 가정한 단가이다. 따라서 다음 보정 계수를 반영해 개발 원가를 구해야 한다.

1. 규모 보정 계수
	- 개발 규모가 너무 작거나 너무 크면 생산성이 감소하는 특성을 반영 
	- 공식의 FP 자리에 500FP 미만 시 1.28, 3,000FP 초과 시 1.153 대입
	- = 0.4057 * (ln(FP) - 7.1978)^2 + 0.8878

2. 애플리케이션 복잡도 보정 계수 (개발하려는 소프트웨어의 복잡도 반영)
	- 연계 복잡성 수준 (타 기관과 연계되는 수)
	- 성능요구 수준
	- 운영 환경 호환성 수준
	- 보안성 수준


##### 7. 조정 기능점수 결정
최종 조정된 기능 점수인 `보정 후 개발 원가`를 구하는 공식은 다음과 같다.
보정 후 개발 원가 = 보정 전 개발 원가 * (규모 보정 계수 * 연계 복잡성 수준 계수 * 성능요구 수준 계수 * 운영 환경 호환성 계수 * 보안성 수준 보정 계수)