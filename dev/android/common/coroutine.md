
하드웨어적으로 특정 시점에 병렬 수행될 수 있는 스레드의 숫자는 `CPU의 코어 수`로 제한된다. 따라서 코어 수보다 많은 수의 스레드가 요구되는 상황에서 OS는 스레드 스케줄링을 수행해 사용할 수 있는 코어들에 작업을 할당하는 정책을 결정한다.

내부적으로 스레드 생성, 스케줄링, 파기를 위해 많은 오버헤드가 수반된다. 따라서 이러한 오버헤드를 피하기 위해 코틀린에서는 코루틴이 실행될 때 새로운 스레드를 실행하고 코루틴이 종료될 때 해당 스레드를 파기하지 않는다. 대신 활성화 상태의 스레드 풀을 유지하고 코루틴들을 해당 스레드에 할당하는 방법을 관리한다.

활성화된 코루틴이 중지되면 해당 코루틴은 코틀린 런타임에 저장되고, 다른 코루틴이 재실행된다. 
재실행된 코루틴은 스레드 풀의 비어 있는 스레드에 원복되고, 완료 혹은 중지될 때까지 계속 실행된다.

---

### 코루틴 스코프
모든 코루틴은 명시적인 스코프 안에서 실행되므로 그룹으로 관리된다. 이는 코루틴을 취소 및 정리하고 누수(leak)되지 않았음을 보장하는데 중요하다.

코틀린과 안드로이드에서는 기본 내장 스코프를 제공하며, CoroutineScope 클래스를 이용해 사용자가 임의로 스코프를 지정할 수 있다. 내장 스코프 목록은 다음과 같다.

#### GlobalScope
애플리케이션의 라이프사이클 전체와 관련된 최상위 코루틴으로, 이 스코프의 코루틴은 불필요한 경우 심지어 액티비티가 종료되었을 때도 실행될 가능성이 있으므로 사용을 권장하지 않는다.
GlobalScope에서 실행되는 코루틴들은 `비구조적인 동시성`을 사용하고 있는 것으로 간주된다.

#### viewModelScope
viewModel 인스턴스 안에서 이 스코프로 실행된 코루틴들은 해당 ViewModel 인스턴스가 파기되는 시점에 코틀린 런타임 시스템에 의해 자동으로 취소된다.

#### lifecycleScope
이 스코프는 해당 라이프사이클 소유자가 파기될 때 취소되며, 이는 컴포저블과 액티비티 안에서 코루틴을 실행할 때 매우 유용하다.

---

### 일시 중단 함수
코루틴 코드를 포함하는 특수한 유형의 코틀린 함수로, 이는 해당 함수가 이후 일시정지 및 재시작될 수 있는 함수, 즉 메인 함수를 막지 않는 상태로 실행되면서 오랜 시간동안 계산할 수 있는 함수임을 의미한다.

---

### 코루틴 디스패처
한 코루틴을 실행할 때 특정한 디스패처를 명시할 수 있다. 디스페처는 코루틴들을 적절한 스레드에 할당하고, 라이프사이클 동안 해당 코루틴들을 중지하고 재시작하는 책임을 진다.

#### Dispatchers.Main
메인 스레드에서 해당 코루틴 실행, UI를 변경하거나 경량의 태스크를 실행하기 위한 일반적인 목적의 코루틴에 적합하다.

#### Dispatchers.IO
네트워크, 디스크, 데이터베이스 작업을 수행하는 코루틴에 적합하다.

#### Dispatchers.Default
데이터 정렬, 복잡한 계산 수행과 같이 많은 CPU 파워를 동반하는 태스크에 효과적이다.

---

### 코루틴 빌더

#### launch
- 현재 스레드를 중단하지 않고 코루틴을 시작
- 호출자에게 결과를 반환하지 않음
- 시작하고 잊어버리는 코루틴(fire and forget)에 사용

#### async
- 다른 중지된 함수 안에서만 사용 가능
- 현재 스레드를 중단시키지 않음
- 호출자가 await()을 통해 결과를 기다리게 할 수 있음

#### withContext
- 부모 코루틴에서 사용된 것과 다른 컨텍스트(디스페처)에서 코루틴을 실행할 수 있음
예를 들어 Main 컨텍스트를 사용해 실행된 코루틴이 withContext를 사용하여 Default 컨텐스트에서 자식 코루틴을 실행할 수 있다.

#### supervisorScope
- coroutineScope과 유사하지만, 한 코루틴에서 실패가 발생해도 다른 모든 자식 코루틴을 취소하지 않음

#### runBlocking
한 코루틴을 실행하고 해당 코루틴이 완료될 때까지 현재 스레드를 중지시킨다.


---

### 잡
launch나 async 같은 모든 코루틴 빌더는 Job 인스턴스를 반환하며, 이를 활용해 해당 코루틴의 라이프사이클을 추적하고 관리할 수 있다. 

부모 코루틴 안에서 빌더를 호출하면 새로운 잡 인스턴스가 생성되며, 이는 부모 잡의 자식이 되어 부모-자식 관계 트리를 구성한다. 이때 부모 잡을 취소하면 해당 부모의 모든 자식 잡도 취소되지만, 자식 잡을 취소하더라도 부모 잡은 취소되지 않는다.

코루틴의 상태는 해당 잡 객체의 isActive, isCompleted, isCancelled 프로퍼티에 접근해서 식별할 수 있다. 또한, cancel() 메서드를 통해 특정 잡과 해당 잡의 모든 자식 잡을 취소할 수 있고, cancelChildren() 메서드를 통해 해당 잡의 모든 자식 잡만 취소할 수도 있다.

join() 메서드를 사용하면 특정 잡의 자식 잡들이 완료될 때까지 해당 잡을 중지할 수 있다.
또한, cancelAndJoin() 메서드는 모든 자식 잡이 완료될 때까지 부모 잡을 중지하고, 완료되었을 때 부모 잡을 취소한다.


---

### 코루틴 채널
채널을 사용하면 데이터 스트림을 포함하는 코루틴 사이의 커뮤니케이션을 간단하게 구현할 수 있다. Channel 인스턴스를 생성한뒤 send() 메서드를 통해 데이터를 전송하고, receive() 메서드 호출을 통해 전달된 데이터를 수신한다.

```kotlin
val channel = Channel<Int>()

coroutineScope.launch() {
    coroutineScope.launch(Dispatchers.Main) { performTask1() }
    coroutineScope.launch(Dispatchers.Main) { performTask2() }
}

suspend fun performTask1() {
    (1..6).forEach { channel.send(it) }
}

suspend fun performTask2() {
    repeat(6) { println("Received: ${channel.receive()}")}
}
```

---

### 부작용
코루틴을 컴포저블 안에서 직접 호출하면 컴파일 에러가 발생한다.
(calls to launch should happen inside a LaunchedEffect and not composition)

즉, 비동기적은 코드가 해당 컴포저블의 라이프사이클을 고려하지 않고 다른 스코프로부터 컴포저블의 상태를 변경하고자 할 때 부작용이 발생한다.

`LaunchedEffect` 또는 `SideEffect` 컴포저블 바디 안에서 코루틴을 실행하면 부모 컴포저블의 라이프사이클을 인식하기 때문에 코루틴을 안전하기 실행할 수 있다. 즉, LaunchedEffect 컴포저블이 호출되면, 해당 코루틴은 즉시 수행되고 부모 컴포저블이 완료되는 즉시, LaunchedEffect 인스턴스와 코루틴이 파기된다.

key 파라미터 값은 재구성을 통해 코루틴의 동작을 통제한다. key 파라미터 값이 변경되지 않으면 부모 컴포저블의 여러 재구성 과정에서도 동일한 코루틴을 유지하고, 변경되면 현재 코루틴을 취소하고 새로운 코루틴을 실행한다. 또한, Unit 인스턴스를 전달하면 재구성 과정에서 해당 코루틴을 재생성하지 않음을 명시할 수 있다.
